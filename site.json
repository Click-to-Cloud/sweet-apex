{"title":"Sweet.apex","githubRepo":"Click-to-Cloud/Sweet.apex","googleAnalytics":"","index":{"title":"Home","description":"Sweet.apex is the next generation of Apex development, transpiling Sweet Apex(a feature-rich Apex-like code) to Apex classes.","content":" Feature Rich Sweet.apex aims to provide features that solve your pain points, and new features are continuously coming. Lightweight Sweet.apex eliminates boilerplates and makes your code more lightweight. Extensible Sweet.apex is built on plugins and welcomes new features. ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/sweet-apex/./","children":{"docs":{"title":"Docs","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/sweet-apex/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/sweet-apex/docs/search.html"},"Core":{"children":{"command":{"title":"Command","description":"Command","layout":"guide","icon":"flash","weight":4,"content":" {$page.description} Command The main entry of Sweet.apex is a node.js command line tool. And you run it like this: node transpile.js Command Arguments The transpile.js expects three optional arguments. node transpile.js [srcDir] [destDir] [features] | Argument Name | Description | | ------------- | ----------- | | srcDir | The source directory or the single file name, using './resources' by default | | destDir | The destination directory, using './build' by default | | features | The list of features enabled, separated by comma, using all features by default | Command Options You can specify command options. | Option Name | Description | | ----------- | ----------- | | -v | Show debug information | | --perf | Show performance information | | -s | Silent mode, disabling all prints | | -c | Clean mode, removing all cache | | -i | Ignore errors, continuing even if a file fails | | -h | Show command line help | | -e | Empty the generated class comment | | -j | Generate JavaScript instead of Apex classes, for development purpose only | ","srcFilePath":"src/pages/docs/Core/command.md","id":"command","location":"/docs/Core/command.html","url":"/sweet-apex/docs/Core/command.html"},"config":{"title":"Config","description":"Config","layout":"guide","icon":"flash","weight":5,"content":" {$page.description} Configuration The configuration in Sweet.apex exists in config.json. You can also specify some config items through command line options, which take a higher priority than configuration. Configuration Items | Config Item | Description | | ----------- | ----------- | | apiVersion | The api version of the generated Apex classes | | isDebugEnabled | Whether debug is enabled, same as '-v' option | | isPerfEnabled | Whether performance logging is enabled, same as '--perf' option | | generateDoc | Whether to generate apexdoc, 'off' turns it off, 'sync' does the synchronous generating and 'async' does the asynchronous | | srcDir | The source directory | | destDir | The destination directory | | docDir | Where the apexdoc is generated | | fileSrcDir | The source directory of the files | | fileDestDir | The destination directory of the files, compiled to static resources | | templateDir | The directory where the templates reside | | scriptDir | The directory for the generated javascript | | scriptName | The generated javascript file name | | scriptAppName | The main javascript object name exposed | | silent | Whether silent mode is enabled, same as '-s' option | | clean | Whether to clean all cache, same as '-c' option | | ignoreErrors | Wheter to continue in case of errors, same as '-i' option | | scanExcludePatterns | The pattern of files to be excluded in the scanning stage | | generatedClassComment | Set the generated class comment | | generateJavaScript | Compile Sweet Apex to JavaScript, for development purpose only | | features | The list of features enabled, separated by comma | ","srcFilePath":"src/pages/docs/Core/config.md","id":"config","location":"/docs/Core/config.html","url":"/sweet-apex/docs/Core/config.html"},"grammar":{"title":"Grammar","description":"Grammar","layout":"guide","icon":"flash","weight":3,"content":" {$page.description} Grammar Sweet.apex uses a lenient grammar that is compatible with Apex grammar except that it is CASE SENSITIVE. We believe that adopting case sensitive way is both a best practice and easier to be implemented. Grammar Parser We use peg.js to generate our parser. To get more details, please check it. Parsing Errors How to show friendly error messages in case of parsing failures has always been a difficult problem. We have tried our best to clearly indicate the error message, yet it still fails our expectation sometimes. Then you have to rely on the error location to detect the errors. ","srcFilePath":"src/pages/docs/Core/grammar.md","id":"grammar","location":"/docs/Core/grammar.html","url":"/sweet-apex/docs/Core/grammar.html"},"transpilation":{"title":"Transpilation","description":"Transpilation","layout":"guide","icon":"flash","weight":2,"content":" {$page.description} Transpilation Transpilation is the process of compiling from one kind of source files to another kind. The actual process is much more sophisticated than this line. And it's helpful for you to have a basic understanding of what Sweet.apex is doing behind the scene. Command To run transpilation, simply type: node transpile.js For details on this command, please check on the commands part. Features Sweet.apex includes a lot of features, and they are delivered in a form of plugins. For now, you only need to get a basic idea of the features. To check more, see the features section. Stages There are several significant stages when you run this command. Scanning The first step of the whole process is to scan all the files in both source directory and destination directory, to generate the typing information of all the classes. Setting Up The next step is to run the setup for each feature. This will be run only once for each feature during one process. Transpiling Then the most important step is to transpile the source Sweet Apex files. Each source file is processed by all available features before the next source file gets started. Finalizing After that is the finalizing step, which runs the finalization for each feature. This will also be run only once for each feature. Building In this step, Sweet.apex will start build files into static resources and copy necessary files. Finishing Clean up the process and finish it. If you want to develop your own feature, please make sure that you have a deep understanding of the stages. Transpilation Stage Transpilation stage is actually the core of the whole process. It is further divided into four parts. Normalizing Here the content of the source file is being cleaned up, and templates are being searched and replaced. Parsing Then our Sweet Apex grammar comes and parses the content into AST(Abstract Syntax Tree) for further processing. Rebuilding In this part, most of the features start their jobs to rebuild the AST nodes to whatever they want. Compiling Finally the AST nodes are compiled to the final string representation. ","srcFilePath":"src/pages/docs/Core/transpilation.md","id":"transpilation","location":"/docs/Core/transpilation.html","url":"/sweet-apex/docs/Core/transpilation.html"}},"title":"Sweet.apex Core","description":"Sweet.apex Core","layout":"guide","icon":"flash","weight":1,"content":" {$page.description} What is Sweet.apex? In essence, Sweet.apex is a developer tool that transpiles your Sweet Apex to Apex classes. What is Sweet Apex? Sweet Apex is a feature-rich Apex-like code that can be transpiled to Apex classes. What is Transpilation? Transpilation is the process of compiling one kind of source files to another kind. Example Well, these concepts are somehow confusing? Then watch the below example. Here is a very simple Sweet Apex file: // Sweet Apex public class HelloSweetApex { public static void main() { Integer a = 5; Integer b = 7; System.debug(a % b); } } At the first glance, you would probably think that it is just an Apex class. You are 90% percent right. Sweet Apex files adopt a very lenient grammar that largely resembles Apex grammar, so that normal Apex classes are actually compatible to Sweet Apex files. The example above is actually not a valid Apex class, because it does not compile due to the use of %. Here is the equivalent Apex version. // Apex Class public class HelloSweetApex { public static void main() { Integer a = 5; Integer b = 7; System.debug(Math.mod(a, b)); } } Transpilation is the process of converting the first version to the second. Sweet Apex - Transpiled - Apex Class Why? Why all the efforts to invent the transpilation thing? Because we want to present you a new development process. This new process looks like this: Writing Sweet Apex - Transpilation - Deployment So now you write Sweet Apex files, instead of Apex classes. Then the transpilation process will convert them to Apex classes. Finally you run DX scripts to deploy your Apex classes. And the question now becomes: Why are we writing Sweet Apex instead of Apex classes? Then the answer is simple: Because we can provide rich features in Sweet Apex, that Apex classes cannot. ","srcFilePath":"src/pages/docs/Core/index.md","id":"Core","location":"/docs/Core/","url":"/sweet-apex/docs/Core/","childIds":["transpilation","grammar","command","config"]},"Development":{"children":{"feature":{"title":"Feature","description":"Feature","layout":"guide","icon":"cloud","weight":2,"content":" {$page.description} Feature Callback Methods To implement a feature, you can choose to provide below methods. | Method Name | Description | | ----------- | ----------- | | setUp(config) | Do the setup | | finalize(config) | Do the finalization | | accept(context) | If the feature accepts this kind of AST node | | run(context) | Run the feature against the AST node | | groupBy(context) | Get the string to group the AST nodes | | runGroup(group) | Run the feature against the AST node group | AST Node Most of the job that a feature does is to handle the AST nodes. You have two ways to do it. Direct Manipulation You create AST nodes purely from javascript and set all the attributes, which is suitable for simple cases. Example: const newNode = { name: { identifier: \"mod\", node: \"SimpleName\", }, expression: { identifier: \"Math\", node: \"SimpleName\", }, node: \"MethodInvocation\", arguments: [ current.leftOperand, current.rightOperand, ], typeArguments: [], }; Parse From String You construct the string and parse it to create the AST node, preferably to be used in complex cases. Example: const newFuncTypeContent = `private class ${funcClassName} extends Func { public ${funcClassName}() { super(${_.size(parameters)}); } public override Object execN(List args) { ${castStatements}; ${lines.join('\\n')}; } }`; const newFuncType = AST.parseTypeDeclaration(newFuncTypeContent); AST Processing You can choose either way to create new AST nodes, but when it comes to impacting the existing AST nodes, you have to use the AST utility library to do this. AST.removeChild(methodDeclaration, 'modifiers', annotation); AST.removeChildren(methodDeclaration.body, 'statements'); Batch Processing If you want to process a group of AST nodes that have some similarities, you can implement groupBy and runGroup, instead of run. Check src/features/not_null/index.js for details. ","srcFilePath":"src/pages/docs/Development/feature.md","id":"feature","location":"/docs/Development/feature.html","url":"/sweet-apex/docs/Development/feature.html"},"testcase":{"title":"Test Case","description":"Test Case","layout":"guide","icon":"cloud","weight":3,"content":" {$page.description} Test Cases Test cases are written with jasmine framework. You need to put your test case in spec directory. Run Test Cases Run the command to start the test cases. jasmine Generate Test Data Make sure that you generate the test data with only the target feature enabled node transpile.js resource/ build/ mod -c -e ","srcFilePath":"src/pages/docs/Development/testcase.md","id":"testcase","location":"/docs/Development/testcase.html","url":"/sweet-apex/docs/Development/testcase.html"}},"title":"Plugin Development","description":"Plugin Development","layout":"guide","icon":"cloud","weight":4,"content":" {$page.description} Sweet.apex Plugin System All Sweet.apex features are implemented as plugins in the src/features directory. To implement your own feature, you need: Create a new directory under src/features Implement your feature in src/features/FeatureName/index.js Register your feature in the feature list in config.json Test your feature Write test cases Write documentations ","srcFilePath":"src/pages/docs/Development/index.md","id":"Development","location":"/docs/Development/","url":"/sweet-apex/docs/Development/","childIds":["feature","testcase"]},"Features":{"children":{"action":{"title":"Action","description":"Action","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} Feature Overview This feature converts a static method into an Action. Prerequisite You need to include Action.apex if you want to enable this feature. Sweet Apex Example public class ActionDemo { /** Some descriptions * @param a The first number @param b The second number */ @AuraEnabled @action public static Integer add(Integer a, Integer b) { return a + b; } } Transpiled Apex public class ActionDemo { private static Action.Registry registry = new Action.Registry(); static { registry.action(new AddAction()); } @AuraEnabled public static Object invoke(String name, Map args) { return registry.invoke(name, args); } @AuraEnabled public static Map apiDescriptorForLightning() { return registry.actions; } /** Some descriptions * @param a The first number @param b The second number */ private class AddAction extends Action { public AddAction() { super('add'); param('a', Integer.class, 'The first number'); param('b', Integer.class, 'The second number'); } public override Object execAction(Object arg0, Object arg1) { Integer a = (Integer)arg0; Integer b = (Integer)arg1; return a + b; } } } Usage @action can only be used on public/global static methods with @AuraEnabled. Some variations are: | Example | Description | | ------- | ----------- | | @action | Convert this method to Action | | @action(true) | Convert this method to Action and set returnRaw(true) | | @action(returnRaw=true) | Convert this method to Action and set returnRaw(true) | ","srcFilePath":"src/pages/docs/Features/action.md","id":"action","location":"/docs/Features/action.html","url":"/sweet-apex/docs/Features/action.html"},"annotation":{"title":"Annotation","description":"Annotation","layout":"guide","icon":"code-file","weight":25,"content":" {$page.description} Feature Overview This feature adds support for custom annotation on classes. Prerequisite None Sweet Apex Example @MyAnnotation(name='Test') public class AnnotationDemo { public @interface MyAnnotation { public String name(); public Integer number() default 10; } } Transpiled Apex public class AnnotationDemo { public class MyAnnotation { private String m_name; private Integer m_number = 10; public MyAnnotation name(String m_name) { this.mname = mname; return this; } public String name() { return this.m_name; } public MyAnnotation number(Integer m_number) { this.mnumber = mnumber; return this; } public Integer number() { return this.m_number; } } } Sweet Annotations public class SweetAnnotations implements Sweet.Annotations { private final Map annotations = new Map(); public List getAnnotations(String name) { List aList = annotations.get(name); return aList == null ? new List() : aList; } public Object getAnnotation(String name) { List aList = getAnnotations(name); return aList.isEmpty() ? null : aList.get(0); } private void registerAnnotation(String targetName, Object annotation) { List aList = annotations.get(targetName); if(aList == null) { aList = new List(); } aList.add(annotation); annotations.put(targetName, aList); } { registerAnnotation(AnnotationDemo.class.getName(), new AnnotationDemo.MyAnnotation().name('Test')); } } Usage Define custom annotations. public @interface MyAnnotation { public String name(); public Integer number() default 10; } Apply custom annotations on classes. @MyAnnotation(name='Test') public class AnnotationDemo { } Retrieve annotation information from the instance of the class. AnnotationDemo demo = new AnnotationDemo(); AnnotationDemo.MyAnnotation myAnn = (AnnotationDemo.MyAnnotation)Sweet.getAnnotation(demo); System.debug(myAnn.name()); ","srcFilePath":"src/pages/docs/Features/annotation.md","id":"annotation","location":"/docs/Features/annotation.html","url":"/sweet-apex/docs/Features/annotation.html"},"apexdoc":{"title":"Apex Doc","description":"Apex Doc","layout":"guide","icon":"code-file","weight":3,"content":" {$page.description} Feature Overview This feature generates the JSON structure of Sweet Apex files with comments. Prerequisite You need to turn on by setting generateDoc to sync/async. Sweet Apex Example /** Sample class for ApexDoc * @author Wilson @version 1.0.0 */ public class ApexDoc { // The name private String name; /** The id * @deprecated */ public String id; /** Run * @example new ApexDoc().run(0); * @param i The seed */ @future(callout=true) public void run(Integer i) { } /** My interface * @author Adam */ public interface MyInterface { } /** My enum * @author Henry */ public enum MyEnum { One, Two, Three; } } Generated JSON { \"type\": \"Class\", \"name\": \"ApexDoc\", \"modifiers\": [ \"public\" ], \"annotations\": [], \"comments\": { \"value\": \"Sample class for ApexDoc\", \"properties\": { \"author\": \"Wilson\", \"version\": \"1.0.0\" } }, \"superclassType\": null, \"superInterfaceTypes\": [], \"typeParameters\": [], \"classDeclarations\": [], \"interfaceDeclarations\": [ { \"type\": \"Interface\", \"name\": \"MyInterface\", \"modifiers\": [ \"public\" ], \"annotations\": [], \"comments\": { \"value\": \"My interface\", \"properties\": { \"author\": \"Adam\" } }, \"superclassType\": null, \"classDeclarations\": [], \"interfaceDeclarations\": [], \"enumDeclarations\": [], \"fieldDeclarations\": [], \"methodDeclarations\": [] } ], \"enumDeclarations\": [ { \"type\": \"Enum\", \"name\": \"MyEnum\", \"modifiers\": [ \"public\" ], \"annotations\": [], \"comments\": { \"value\": \"My enum\", \"properties\": { \"author\": \"Henry\" } }, \"superInterfaceTypes\": [], \"classDeclarations\": [], \"interfaceDeclarations\": [], \"enumDeclarations\": [], \"fieldDeclarations\": [], \"methodDeclarations\": [] } ], \"fieldDeclarations\": [ [ { \"name\": \"name\", \"type\": \"String\", \"modifiers\": [ \"private\" ], \"annotations\": [], \"comments\": {} } ], [ { \"name\": \"id\", \"type\": \"String\", \"modifiers\": [ \"public\" ], \"annotations\": [], \"comments\": { \"value\": \"The id\", \"properties\": { \"deprecated\": \"\" } } } ] ], \"methodDeclarations\": [ { \"name\": \"run\", \"modifiers\": [ \"public\" ], \"annotations\": [ { \"typeName\": \"future\", \"values\": [ { \"name\": \"callout\", \"value\": \"true\" } ] } ], \"constructor\": false, \"parameters\": [ { \"name\": \"i\", \"type\": \"Integer\" } ], \"returnType\": \"void\", \"comments\": { \"value\": \"Run\", \"properties\": { \"example\": \"new ApexDoc().run(0);\", \"param\": \"i The seed\" } } } ] } Usage This feature is enabled only when 'generateDoc' is turned to 'sync/async' and 'docDir' is set. ","srcFilePath":"src/pages/docs/Features/apexdoc.md","id":"apexdoc","location":"/docs/Features/apexdoc.html","url":"/sweet-apex/docs/Features/apexdoc.html"},"array_creation":{"title":"Array Creation","description":"Array Creation","layout":"guide","icon":"code-file","weight":4,"content":" {$page.description} Feature Overview This feature enables simple creation of arrays/lists and maps. Prerequisite None Sweet Apex Example public class ArrayCreation { public static void run(Object o) { } public static void main() { Map m = new Map{ 'a': 2, }; List l = new List{ 'a', }; Map m1 = { 'a' = 2 }; List l1 = { 'a' }; Object m2 = { 'a' = 2 }; Object l2 = { 'a' }; Map m3 = { 'a' = { 'b' = 2 } }; List l3 = { { 'a' } }; run({ 'a' = 2 }); run({ 'a' }); } } Transpiled Apex public class ArrayCreation { public static void run(Object o) { } public static void main() { Map m = new Map{ 'a' = 2 }; List l = new List{ 'a' }; Map m1 = new Map{ 'a' = 2 }; List l1 = new List{ 'a' }; Object m2 = new Map{ 'a' = 2 }; Object l2 = new List{ 'a' }; Map m3 = new Map{ 'a' = new Map{ 'b' = 2 } }; List l3 = new List{ new List{ 'a' } }; run(new Map{ 'a' = 2 }); run(new List{ 'a' }); } } Usage When enabled, this feature helps you to complete the array creation. ","srcFilePath":"src/pages/docs/Features/array_creation.md","id":"array_creation","location":"/docs/Features/array_creation.html","url":"/sweet-apex/docs/Features/array_creation.html"},"aspect":{"title":"Aspect","description":"Aspect","layout":"guide","icon":"code-file","weight":5,"content":" {$page.description} Feature Overview This feature applies aspects onto methods. Aspects represent cross-cutting concerns like logging, validation and so on. Using AOP(Aspect Oriented Programming), our code will look clean and the core business logic code is more condensed. Prerequisite You need to have some basic understanding of Aspect Oriented Programming. Sweet Apex Example public class AspectDemo { @afterMethod('AspectDemo.version') public static Integer afterVersion(Sweet.MethodInfo method, List args, Object result) { return (Integer)result + 1; } public static Integer version(Integer base) { return base + 1; } } Transpiled Apex public class AspectDemo { public static Integer afterVersion(Sweet.MethodInfo method, List args, Object result) { return (Integer)result + 1; } public static Integer version(Integer base) { Integer ret = aspect_version(base); ret = (Integer)AspectDemo.afterVersion(new Sweet.MethodInfo('version', AspectDemo.class, null, new List{ Integer.class }), new List{ base }, ret); return ret; } private static Integer aspect_version(Integer base) { return base + 1; } } Usage This feature includes two annotations, @beforeMethod and @afterMethod. They can only be applied to public/global static methods that accept the following arguments. @beforeMethod Method name is not important but it should be expecting (Object, List). The first argument will be the method info for this aspect. The second argument will be the list of arguments passed to the target method. @afterMethod Method name is not important but it should be expecting (Object, List, Object). The first argument will be the method info for this aspect. The second argument will be the list of arguments passed to the target method. The third argument will be the result of the target method. An aspect here is any method marked with the annotation @beforeMethod or @afterMethod. This feature will scan all the source files to find all the aspects before trying to apply them to the target methods. So you can make any method to be an aspect and expect it to be applied to other source files. ","srcFilePath":"src/pages/docs/Features/aspect.md","id":"aspect","location":"/docs/Features/aspect.html","url":"/sweet-apex/docs/Features/aspect.html"},"cast":{"title":"Cast","description":"Cast","layout":"guide","icon":"code-file","weight":6,"content":" {$page.description} Feature Overview This feature casts between different collections of lists, sets and maps. Prerequisite None Sweet Apex Example public class CastDemo { public static void main() { List list1 = (List = List)new List(); Map map1 = (Map = Map)new Map(); } } Transpiled Apex public class CastDemo { public static void main() { List list1 = castUtils.castListObjecttoListString(new List()); Map map1 = castUtils.castMapObjectObjecttoMapStringString(new Map()); } } public class cast_Utils { public static List castListObjecttoList_String(Object other) { List target = (List)other; List ret = new List(); for(Object i : target) { String r = (String)i; ret.add(r); } return ret; } public static Map castMapObjectObjecttoMapString_String(Object other) { Map target = (Map)other; Map ret = new Map(); for(Object key : target.keySet()) { Object value = target.get(key); String k = (String)key; String v = (String)value; ret.put(k, v); } return ret; } } Usage An extra cast_Utils.cls will be generated to contain all the casting methods should it be used by other files. Nested casting like (List = List) is also supported. ","srcFilePath":"src/pages/docs/Features/cast.md","id":"cast","location":"/docs/Features/cast.html","url":"/sweet-apex/docs/Features/cast.html"},"default_value":{"title":"Default Value","description":"Default Value","layout":"guide","icon":"code-file","weight":7,"content":" {$page.description} Feature Overview This feature sets the default value for method parameters. Prerequisite None Sweet Apex Example public class DefaultValueDemo { public static Integer init() { return 0; } public static Integer add( @defaultValue(init()) Integer a, Integer b = init() ) { return a + b; } } Transpiled Apex public class DefaultValueDemo { public static Integer init() { return 0; } public static Integer add(Integer a, Integer b) { a = (a == null) ? init() : a; b = (b == null) ? init() : b; return a + b; } } Usage @defaultValue can only be applied to method parameters. Or you can append = ... expressions to the parameter name. ","srcFilePath":"src/pages/docs/Features/default_value.md","id":"default_value","location":"/docs/Features/default_value.html","url":"/sweet-apex/docs/Features/default_value.html"},"enum":{"title":"Enum","description":"Enum","layout":"guide","icon":"code-file","weight":8,"content":" {$page.description} Feature Overview This feature generates a full-fledged enum class. Prerequisite None Sweet Apex Example public enum EnumDemo { One('1'), Two('2'), Three('3'); private String id; private EnumDemo(String id) { this.id = id; } public String getId() { return this.id; } } Transpiled Apex public class EnumDemo extends Sweet.BaseEnum { public static final EnumDemo One = (EnumDemo)new EnumDemo('1').setName('One').setOrdinal(0); public static final EnumDemo Two = (EnumDemo)new EnumDemo('2').setName('Two').setOrdinal(1); public static final EnumDemo Three = (EnumDemo)new EnumDemo('3').setName('Three').setOrdinal(2); private static final Map instances = new Map{ 'One' = One, 'Two' = Two, 'Three' = Three }; public static List values() { return instances.values(); } public static EnumDemo valueOf(String name) { return instances.get(name); } private String id; private EnumDemo(String id) { this.id = id; } public String getId() { return this.id; } } Usage Generated enums are all subclasses of Sweet.BaseEnum, and they share the same API. | Method Name | Description | | ----------- | ----------- | | toString() | Get the name of the enum | | ordinal() | Get the ordinal of the enum | | static BaseEnum valueOf(String) | Get the enum by name | | static List&lt;BaseEnum&gt; values() | Get all enum values | ","srcFilePath":"src/pages/docs/Features/enum.md","id":"enum","location":"/docs/Features/enum.html","url":"/sweet-apex/docs/Features/enum.html"},"file":{"title":"File","description":"File","layout":"guide","icon":"code-file","weight":9,"content":" {$page.description} Feature Overview This feature converts files to static resources. Prerequisite None Sweet Apex Example public class FileDemo { public static void main() { @file(name='beans') String content = null; } } Transpiled Apex public class FileDemo { public static void main() { String content = Sweet.readFile('beans'); } } Usage The source directories and destination directories of the files are controlled by fileSrcDir and fileDestDir in the config. When you need to use a file, you can create one in the file source directory. Sweet.apex will compile it to a static resource. You need to deploy the static resource to make the code work. ","srcFilePath":"src/pages/docs/Features/file.md","id":"file","location":"/docs/Features/file.html","url":"/sweet-apex/docs/Features/file.html"},"function":{"title":"Function","description":"Function","layout":"guide","icon":"code-file","weight":10,"content":" {$page.description} Feature Overview This feature converts a static method to a Func. For more details on Funcs, please check R.apex. Prerequisite You need to include R.apex if you want to enable this feature. Sweet Apex Example public class FunctionDemo { /** A sample add function */ @func public static Integer add(Integer a, Integer b) { return a + b; } public static void test() { System.debug(FuctionDemo.F.add.run(1, 2)); } } Transpiled Apex public class FunctionDemo { /** A sample add function */ public static Integer add(Integer a, Integer b) { return (Integer)F.add.runN(new List{ a, b }); } public static void test() { System.debug(FuctionDemo.F.add.run(1, 2)); } public static final Funcs F = new Funcs(); public class Funcs { public Func add = new AddFunc(); } private class AddFunc extends Func { public AddFunc() { super(2); } public override Object execN(List args) { Integer a = args.get(0) == null ? null : (Integer)args.get(0); Integer b = args.get(1) == null ? null : (Integer)args.get(1); return a + b; } } } Usage @func works only with static methods. To use the generated Funcs, you will have to refer to ClassName.F.funcName. ","srcFilePath":"src/pages/docs/Features/function.md","id":"function","location":"/docs/Features/function.html","url":"/sweet-apex/docs/Features/function.html"},"identity":{"title":"Identity","description":"Identity","layout":"guide","icon":"code-file","weight":11,"content":" {$page.description} Feature Overview This feature generates equals and hashCode methods for the class. Prerequisite None Sweet Apex Example @identity public class IdentityDemo { private String name; private Integer id; private Boolean active; } Transpiled Apex public class IdentityDemo { private String name; private Integer id; private Boolean active; public Boolean equals(Object other) { if(other instanceof IdentityDemo) { IdentityDemo target = (IdentityDemo)other; return this.name == target.name && this.id == target.id && this.active == target.active; } return false; } public Integer hashCode() { Map data = new Map(); data.put('name', this.name); data.put('id', this.id); data.put('active', this.active); return Sweet.generateHashCode(data); } } Usage @identity only includes non-static fields. Some variations are: | Example | Description | | ------- | ----------- | | @identity | Generate all non-static fields | | @identity(&amp;#123; 'name', 'id' &amp;#125;) | Generate the given fields | | @identity(fields=&amp;#123; 'name', 'id' &amp;#125;) | Generate the given fields | ","srcFilePath":"src/pages/docs/Features/identity.md","id":"identity","location":"/docs/Features/identity.html","url":"/sweet-apex/docs/Features/identity.html"},"inject":{"title":"Injection","description":"Injection","layout":"guide","icon":"code-file","weight":12,"content":" {$page.description} Feature Overview This feature injects dependency. See DI(Dependency Injection) for more details. Prerequisite You need to configure the beans.json file should you want to use the named beans. Sweet Apex Example public class InjectDemo { @inject private Case c1; @inject('demo') private Case c2; } Transpiled Apex public class InjectDemo { private Case c1 = (Case)Sweet.getBean(Case.class); private Case c2 = (Case)Sweet.getBean('demo'); } Usage @inject works for two scenarios. Named Injections To inject a named bean, you need to configure it in the beans.json like this: [ { \"name\": \"demo\", \"type\": \"Case\" } ] Type Injections To inject a typed bean, you need to bind the type first. Sweet.bind(Case.class, Account.class); // Bind Case.class to be created by Account.class Sweet.bindObject(Case.class, mockCase); // Bind Case.class to a created object If no bindings are found, the original type will be used to create the instance. ","srcFilePath":"src/pages/docs/Features/inject.md","id":"inject","location":"/docs/Features/inject.html","url":"/sweet-apex/docs/Features/inject.html"},"lambda":{"title":"Lambda","description":"Lambda","layout":"guide","icon":"code-file","weight":13,"content":" {$page.description} Feature Overview This feature converts a lambda expression to an anonymous Func. Check details on R.apex. Prerequisite You need to include R.apex if you want to enable this feature. Sweet Apex Example public class LambdaDemo { public static Func f = (Integer a) - { return a + 1; }; } Transpiled Apex public class LambdaDemo { public static Func f = new AnonymousFunc0(new Sweet.AnonymousContext(null, new Map{ })); private class AnonymousFunc0 extends Func { private Sweet.AnonymousContext anonymous_context; public AnonymousFunc0(Sweet.AnonymousContext context) { super(1); this.anonymous_context = context; } public override Object execN(List args) { Integer a = args.get(0) == null ? null : (Integer)args.get(0); return a + 1; } } } Usage Lambda expression are like (Type1 name1, Type2 name2) - &#123; ... &#125;. We convert lambda expression to anonymous functions. Here are the things we need to pay attention to: Lambda expressions take this as reference to the enclosing object, not the functions. Nested lambda expressions are supported. You can refer to variables from enclosing block by using outer.Xxx, but this does NOT support nested lambda expressions. ","srcFilePath":"src/pages/docs/Features/lambda.md","id":"lambda","location":"/docs/Features/lambda.html","url":"/sweet-apex/docs/Features/lambda.html"},"log":{"title":"Log","description":"Log","layout":"guide","icon":"code-file","weight":14,"content":" {$page.description} Feature Overview This feature generates the logger object for the class. Prerequisite You need to include Log.apex if you want to enable this feature. Sweet Apex Example @log public class LogDemo { public static void main() { System.debug('Logging'); } } Transpiled Apex public class LogDemo { public static final Log logger = Log.getLogger(LogDemo.class); public static void main() { System.debug('Logging'); } } Usage @log can only be applied to top level classes, as static variables can only be declared in top level classes. ","srcFilePath":"src/pages/docs/Features/log.md","id":"log","location":"/docs/Features/log.html","url":"/sweet-apex/docs/Features/log.html"},"map_access":{"title":"Map Access","description":"Map Access","layout":"guide","icon":"code-file","weight":29,"content":" {$page.description} Feature Overview This feature adds array access support to maps. Prerequisite None Sweet Apex Example public class MapAccess { public static void main() { Map count = new Map{ 'a' = 2 }; Integer i = count['a']; ++count['a']; count['a']++; count['a'] += 2; List nums = new List{ 2 }; Integer j = nums[0]; ++nums[0]; nums[0]++; nums[0] += 2; } } Transpiled Apex public class MapAccess { public static void main() { Map count = new Map{ 'a' = 2 }; Integer i = count.get('a'); count.put('a', count.get('a') + 1); count.put('a', count.get('a') + 1); count.put('a', count.get('a') + 2); List Integer nums = new List{ 2 }; Integer j = nums[0]; ++nums[0]; nums[0]++; nums[0] += 2; } } Usage Array access for maps support assignment expressions, postfix expressions, and prefix expressions. Postfix and prefix expressions of map access cannot be used in assignments. ","srcFilePath":"src/pages/docs/Features/map_access.md","id":"map_access","location":"/docs/Features/map_access.html","url":"/sweet-apex/docs/Features/map_access.html"},"mod":{"title":"Mod","description":"Mod","layout":"guide","icon":"code-file","weight":15,"content":" {$page.description} Feature Overview This feature converts % to Math.mod. Prerequisite None Sweet Apex Example public class ModDemo { public static void test() { System.debug(1 % 5); } } Transpiled Apex public class ModDemo { public static void test() { System.debug(Math.mod(1, 5)); } } Usage ","srcFilePath":"src/pages/docs/Features/mod.md","id":"mod","location":"/docs/Features/mod.html","url":"/sweet-apex/docs/Features/mod.html"},"not_null":{"title":"Not Null","description":"Not Null","layout":"guide","icon":"code-file","weight":16,"content":" {$page.description} Feature Overview This feature guards that method parameters cannot be null. Prerequisite None Sweet Apex Example public class NotNullDemo { public static Integer add( @notNull Integer a, Integer b! ) { return a + b; } } Transpiled Apex public class NotNullDemo { public static Integer add(Integer a, Integer b) { Sweet.assertNotNull(a, '\"a\" in NotNullDemo.add(Integer, Integer) should not be null'); Sweet.assertNotNull(b, '\"b\" in NotNullDemo.add(Integer, Integer) should not be null'); return a + b; } } Usage @notNull can only be used on method parameters. Or you can append ! after the parameter variable. ","srcFilePath":"src/pages/docs/Features/not_null.md","id":"not_null","location":"/docs/Features/not_null.html","url":"/sweet-apex/docs/Features/not_null.html"},"nullable":{"title":"Nullable","description":"Nullable","layout":"guide","icon":"code-file","weight":26,"content":" {$page.description} Feature Overview This feature adds support for nullable variables. Prerequisite None Sweet Apex Example public class NullableDemo { public static void main() { String s1 = 'abc'; Integer i1 = s1.length(); String s2 = null; Integer i2 = s2?.length(); Integer i3 = ('a' + 'b')?.length(); } } Transpiled Apex public class NullableDemo { public static void main() { String s1 = 'abc'; Integer i1 = s1.length(); String s2 = null; Integer i2 = (s2 != null ? s2.length() : null); Integer i3 = (('a' + 'b') != null ? ('a' + 'b').length() : null); } } Usage Use nullable variables in method invocations or field accesses. Try not using nest nullable variables as this will increase complexity. ","srcFilePath":"src/pages/docs/Features/nullable.md","id":"nullable","location":"/docs/Features/nullable.html","url":"/sweet-apex/docs/Features/nullable.html"},"operator":{"title":"Operator","description":"Operator","layout":"guide","icon":"code-file","weight":17,"content":" {$page.description} Feature Overview This feature converts a static method to an operator. Prerequisite None Sweet Apex Example public class OperatorDemo { @operator public static Integer add(Integer a, Integer b) { return a + b; } public static void main() { Object a = 1; Object b = 2; System.debug(a add b); } } Transpiled Apex public class OperatorDemo { public static Integer add(Integer a, Integer b) { return a + b; } public static void main() { Object a = 1; Object b = 2; System.debug((Integer)OperatorDemo.add((Integer)a, (Integer)b)); } } Usage @operator can only be used on public/global static methods with two parameters and one return value. Some variations are: | Example | Description | | ------- | ----------- | | @operator | Convert the method to an operator | | @operator('name') | Convert the method to an operator with the given name | | @operator(name='name') | Convert the method to an operator with the given name | ","srcFilePath":"src/pages/docs/Features/operator.md","id":"operator","location":"/docs/Features/operator.html","url":"/sweet-apex/docs/Features/operator.html"},"optional":{"title":"Optional","description":"Optional","layout":"guide","icon":"code-file","weight":18,"content":" {$page.description} Feature Overview This feature generates a method with optional parameters. Prerequisite None Sweet Apex Example public class OptionalDemo { public static Integer add(Integer a, @optional Integer b, Integer c?) { b = b == null ? 0 : b; c = c == null ? 0 : c; return a + b + c; } } Transpiled Apex public class OptionalDemo { public static Integer add(Integer a, Integer b, Integer c) { b = b == null ? 0 : b; c = c == null ? 0 : c; return a + b + c; } public static Integer add(Integer a, Integer b) { return add(a, b, null); } public static Integer add(Integer a) { return add(a, null); } } Usage @optional can only be used as the rear parameters in a method. Or you can append ? to the parameter name. ","srcFilePath":"src/pages/docs/Features/optional.md","id":"optional","location":"/docs/Features/optional.html","url":"/sweet-apex/docs/Features/optional.html"},"reflect":{"title":"Reflection","description":"Reflection","layout":"guide","icon":"code-file","weight":19,"content":" {$page.description} Feature Overview This feature generates reflection code for a class. Prerequisite None Sweet Apex Example @reflect public class ReflectDemo { private static String version = '1.0'; private String name; private Integer count; public ReflectDemo() { } public String getName() { return this.name; } public Integer getCount() { return this.count; } public void setCount(Integer count) { this.count = count; } public static void test() { ReflectDemo demo = new ReflectDemo(); Sweet.Reflection reflection = Sweet.reflect(demo); } } Transpiled Apex public class ReflectDemo implements Sweet.Reflectable { private static String version = '1.0'; private String name; private Integer count; public ReflectDemo() { } public String getName() { return this.name; } public Integer getCount() { return this.count; } public void setCount(Integer count) { this.count = count; } public static void test() { ReflectDemo demo = new ReflectDemo(); Sweet.Reflection reflection = Sweet.reflect(demo); } public List reflect_getFieldNames() { return new List{ 'name', 'count' }; } public Object reflect_getFieldValue(String name) { if(name == 'name') { return this.name; } else { if(name == 'count') { return this.count; } else { throw new Sweet.SweetException('Field ' + name + ' does not exist'); } } } public void reflect_setFieldValue(String name, Object value) { if(name == 'name') { this.name = (String)value; } else { if(name == 'count') { this.count = (Integer)value; } else { throw new Sweet.SweetException('Field ' + name + ' does not exist'); } } } public List reflect_getMethodNames() { return new List{ 'getName', 'getCount', 'setCount' }; } public Object reflect_invokeMethod(String name, List args) { if(name == 'getName') { return this.getName(); } else { if(name == 'getCount') { return this.getCount(); } else { if(name == 'setCount') { this.setCount((Integer)args.get(0)); } else { throw new Sweet.SweetException('Method ' + name + ' does not exist'); } } } return null; } } Usage @reflect can only generate reflection methods on non-static fields and methods(excluding constructors). Here is how you can use the reflection. Sweet.Reflection r = Sweet.reflect(target); Object value = r.getFieldValue('name'); ","srcFilePath":"src/pages/docs/Features/reflect.md","id":"reflect","location":"/docs/Features/reflect.html","url":"/sweet-apex/docs/Features/reflect.html"},"rethrow":{"title":"Rethrow","description":"Rethrow","layout":"guide","icon":"code-file","weight":20,"content":" {$page.description} Feature Overview This feature catches any exception thrown from the method and rethrows the wrapped exception. Prerequisite None Sweet Apex Example public class Rethrow { @AuraEnabled @rethrow(AuraHandledException) public static void test() { System.debug('Rethrow exceptions'); } } Transpiled Apex public class Rethrow { @AuraEnabled public static void test() { try { System.debug('Rethrow exceptions'); } catch(Exception e) { System.debug(LoggingLevel.Error, e.getStackTraceString()); throw new AuraHandledException(e.getMessage()); } } } Usage @rethrow can only be used on methods. ","srcFilePath":"src/pages/docs/Features/rethrow.md","id":"rethrow","location":"/docs/Features/rethrow.html","url":"/sweet-apex/docs/Features/rethrow.html"},"script":{"title":"Script","description":"Script","layout":"guide","icon":"code-file","weight":24,"content":" {$page.description} Feature Overview This feature generates javascript functions for Apex methods. Prerequisite None Sweet Apex Example public class ScriptDemo { /** Some comments */ @script public static Integer add(Integer a, Integer b) { return a + b; } @script public static String env() { /* @script return 'script'; */ return 'apex'; } } Transpiled Apex public class ScriptDemo { /** Some comments */ public static Integer add(Integer a, Integer b) { return a + b; } public static String env() { /* @script return 'script'; */ return 'apex'; } } Generated JavaScript The script is generated by the name sweetApp.js in the script directory set in the config. ;; (function() { const ScriptDemo = {}; /** Some comments */ const ScriptDemo_add = function add(a, b) { return a + b; } const ScriptDemo_env = function env() { return 'script'; } ScriptDemo.add = ScriptDemo_add; ScriptDemo.env = ScriptDemo_env; const $SweetApp = {}; $SweetApp.ScriptDemo = ScriptDemo; window.$SweetApp = $SweetApp; })(); Usage @script can only be used on public/global static methods. The main purpose of this feature is to generate both JavaScript code and Apex code that produce the same result, so that the same business logic can be applied both front end and back end. A @script function can be in either form: Native Script Form Besides the @script, you need to add a comment including the javascript implementation of this method, like env() in the example, inside your Apex method. This way Sweet.apex will use the native javascript code to generate the javascript function. Interpreted Form You only need the @script and Sweet.apex will transpile your Apex code to javascript code. Note that Sweet.apex only transpiles the direct Apex method, not including any nested method calls. So if you call any other Apex methods, make sure that they are also @script methods. ","srcFilePath":"src/pages/docs/Features/script.md","id":"script","location":"/docs/Features/script.html","url":"/sweet-apex/docs/Features/script.html"},"switch":{"title":"Switch","description":"Switch","layout":"guide","icon":"code-file","weight":21,"content":" {$page.description} Feature Overview This feature converts switch-case structure to nested if-else. Prerequisite None Sweet Apex Example public class SwitchDemo { public static void test() { Integer i = 3; switch(i) { case 0: System.debug('0'); break; case 1: case 2: System.debug('other'); default: return; } } } Transpiled Apex public class SwitchDemo { public static void test() { Integer i = 3; Object SwitchDemotests = i; if(SwitchDemotests == 0) { System.debug('0'); } else { if(SwitchDemotests == 1) { } if(SwitchDemotests == 2) { System.debug('other'); } return; } } } Usage ","srcFilePath":"src/pages/docs/Features/switch.md","id":"switch","location":"/docs/Features/switch.html","url":"/sweet-apex/docs/Features/switch.html"},"tagged_string":{"title":"Tagged String","description":"Tagged String","layout":"guide","icon":"code-file","weight":24,"content":" {$page.description} Feature Overview This feature converts tagged strings into method calls. Prerequisite None Sweet Apex Example public class TaggedStringDemo { @tag public static String n(List items, List values) { return 'prefix__' + String.join(items, ''); } public static void main() { String s = nName; } } Transpiled Apex public class TaggedStringDemo { public static String n(List items, List values) { return 'prefix__' + String.join(items, ''); } public static void main() { String s = (String)TaggedStringDemo.n(new List{ 'Name' }, new List{ }); } } Usage Methods with @tag annotation should be public/global static and accept parameters of List and List. ","srcFilePath":"src/pages/docs/Features/tagged_string.md","id":"tagged_string","location":"/docs/Features/tagged_string.html","url":"/sweet-apex/docs/Features/tagged_string.html"},"template":{"title":"Template","description":"Template","layout":"guide","icon":"code-file","weight":23,"content":" {$page.description} Feature Overview This feature converts templates in the source files. Prerequisite You need to create template files in the template directory set in the config file. Sweet Apex Example @log public class TemplateDemo { public static void main() { #debug('Hello World') #debug('a\\,b', 'c\\,d') } } Transpiled Apex public class TemplateDemo { public static final Log logger = Log.getLogger(TemplateDemo.class); public static void main() { if(logger.isDebugEnabled()) { logger.debug('Hello World'); } if(logger.isDebugEnabled()) { logger.debug('a,b', 'c,d'); } } } Usage Here is an example of how to create a new template definition. // In debug.js const _ = require('lodash'); const debug = (...values) = ` if(logger.isDebugEnabled()) { logger.debug(${_.join(values, ', ')}); } `; module.exports = debug; Place this js file in the template directory set in the config file and Sweet.apex will load it. Here is how you would invoke this template. debug('Hello World') `` starts the template, and anything between the following parenthesis, separated by comma, will be passed in as the arguments. For example, test(abc, def) ","srcFilePath":"src/pages/docs/Features/template.md","id":"template","location":"/docs/Features/template.html","url":"/sweet-apex/docs/Features/template.html"},"template_string":{"title":"Template String","description":"Template String","layout":"guide","icon":"code-file","weight":22,"content":" {$page.description} Feature Overview This feature converts a template string into concatenated strings. Prerequisite None Sweet Apex Example public class TemplateStringDemo { public static String a = 'a'; public static String b = 'b'; public static String c = ${a}-${b}; public static String text = ` This is a free style text. You can add ${c} here. Try it. `; } Transpiled Apex public class TemplateStringDemo { public static String a = 'a'; public static String b = 'b'; public static String c = '' + a + '-' + b + ''; public static String text = '\\n This is a free style text.\\n You can add ' + c + ' here.\\n Try it.\\n '; } Usage ","srcFilePath":"src/pages/docs/Features/template_string.md","id":"template_string","location":"/docs/Features/template_string.html","url":"/sweet-apex/docs/Features/template_string.html"},"val":{"title":"Val","description":"Val","layout":"guide","icon":"code-file","weight":28,"content":" {$page.description} Feature Overview This feature infers variable types according to the context and make it final. Prerequisite None Sweet Apex Example public class ValDemo { public static void main() { val t = 'String'; val size = t.length(); val str = t.toString(); val acc = new Account(); String [] slist = { 'a' }; val ref = slist; } } Transpiled Apex public class ValDemo { public static void main() { final String t = 'String'; final Integer size = t.length(); final String str = t.toString(); final Account acc = new Account(); List slist = { 'a' }; final List ref = slist; } } Usage Refer to feature var for more details. ","srcFilePath":"src/pages/docs/Features/val.md","id":"val","location":"/docs/Features/val.html","url":"/sweet-apex/docs/Features/val.html"},"var":{"title":"Var","description":"Var","layout":"guide","icon":"code-file","weight":27,"content":" {$page.description} Feature Overview This feature infers variable types according to the context. Prerequisite None Sweet Apex Example public class VarDemo { public static void main() { var t = 'String'; var size = t.length(); var str = t.toString(); var acc = new Account(); String [] slist = { 'a' }; var ref = slist; } } Transpiled Apex public class VarDemo { public static void main() { String t = 'String'; Integer size = t.length(); String str = t.toString(); Account acc = new Account(); List slist = { 'a' }; List ref = slist; } } Usage This feature uses the typing information to infer the variable type. Currently, classes under namespace System have typings imported by default. Typing information in source directory will be scanned by default. Configure scanDestDir to scan the destination directory to collect the typing information. If you want to add any extra directory to scan, add it in classpath, separated by : if there are multiple values. Exceptions will be thrown if it fails to infer the correct type. ","srcFilePath":"src/pages/docs/Features/var.md","id":"var","location":"/docs/Features/var.html","url":"/sweet-apex/docs/Features/var.html"}},"title":"Features","description":"Features","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} Sweet.apex Features Here is the reference of all features supported in Sweet.apex. You can specify the feature list either in the config file or by the command line. Feature Orders When there are multiple features, the order matters. During transpilation, features are applied to the source files one after another, and the order is specified in the feature list. Adjust the feature order carefully and make sure you understand the consequences. ","srcFilePath":"src/pages/docs/Features/index.md","id":"Features","location":"/docs/Features/","url":"/sweet-apex/docs/Features/","childIds":["action","apexdoc","array_creation","aspect","cast","default_value","enum","file","function","identity","inject","lambda","log","mod","not_null","operator","optional","reflect","rethrow","switch","template_string","template","script","tagged_string","annotation","nullable","var","val","map_access"]}},"childIds":["Core","Features","Development","search"]},"tutorials":{"title":"Tutorials","description":"The tutorials","url":"/sweet-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials/","customURL":true,"children":{"getting_started":{"title":"Getting Started","description":"The Getting Started Tutorial","tutorialTitle":"Getting started with Sweet.apex","url":"/sweet-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/getting_started/index.soy","id":"getting_started","location":"/tutorials/getting_started/","customURL":true,"children":{"step_1":{"title":"Installation","description":"Installation","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Sweet.apex is a JavaScript project based on node.js. Make sure you have node.js and npm installed before you go on. Clone the project from the github repo, go to the root of the project and run the command. npm install Wait until the installation is finished. ","srcFilePath":"src/pages/tutorials/getting_started/step_1.md","id":"step_1","location":"/tutorials/getting_started/step_1.html","url":"/sweet-apex/tutorials/getting_started/step_1.html"},"step_2":{"title":"Write First Sweet Apex","description":"Write First Sweet Apex","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} Go to any directory(/Users/wilson/sweet_apex/src, for example), and write a simple Sweet Apex file. public class HelloSweetApex { public static void main() { Integer a = 5; Integer b = 7; System.debug(a % b); } } Well, this is simple. But be careful. This file won't compile in Apex, because % is not supported. However, we are writing Sweet Apex files, and we will see what will happen. ","srcFilePath":"src/pages/tutorials/getting_started/step_2.md","id":"step_2","location":"/tutorials/getting_started/step_2.html","url":"/sweet-apex/tutorials/getting_started/step_2.html"},"step_3":{"title":"Transpile It","description":"Transpile It","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} Let's say you want to build your Sweet Apex files into a directory called /Users/wilson/sweet_apex/build. Run the following command in the root of the project. node transpile.js /Users/wilson/sweetapex/src /Users/wilson/sweetapex/build Wait until it says it's completed. ","srcFilePath":"src/pages/tutorials/getting_started/step_3.md","id":"step_3","location":"/tutorials/getting_started/step_3.html","url":"/sweet-apex/tutorials/getting_started/step_3.html"},"step_4":{"title":"Transpiled Apex Class","description":"Transpiled Apex Class","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":4,"content":" {$page.title} Go to /Users/wilson/sweet_apex/build and check what has been generated. You can find a file called HelloSweetApex.cls, and it looks like this: public class HelloSweetApex { public static void main() { Integer a = 5; Integer b = 7; System.debug(Math.mod(a, b)); } } Note that a % b has been translated to Math.mod(a, b). This is a typical example of how Sweet Apex codes are transpiled to Apex codes. ","srcFilePath":"src/pages/tutorials/getting_started/step_4.md","id":"step_4","location":"/tutorials/getting_started/step_4.html","url":"/sweet-apex/tutorials/getting_started/step_4.html"},"step_5":{"title":"Deploy and Check","description":"Deploy and Check","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":5,"content":" {$page.title} The next thing is definitely running your DX tools to deploy the code to your Org and check if it actually works. ","srcFilePath":"src/pages/tutorials/getting_started/step_5.md","id":"step_5","location":"/tutorials/getting_started/step_5.html","url":"/sweet-apex/tutorials/getting_started/step_5.html"}},"childIds":["step_1","step_2","step_3","step_4","step_5"]}},"childIds":["getting_started"]}},"childIds":["docs","tutorials"]},"basePath":"/sweet-apex"}